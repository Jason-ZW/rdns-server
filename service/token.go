package service

import (
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/bcrypt"
)

const (
	// generated by bcrypt.GenerateFromPassword("lb.rancher.cloud", bcrypt.MinCost)
	defaultToken = "$2a$04$7nET8ovKeMwgcV7ia8qdteT7.nlldONYsYyhKiqJ1rJjKojVZUM9a"
)

// getBaseFqdn can return a base fqdn
// xx.<cluster_id>.lb.rancher.cloud == > <cluster_id>.lb.rancher.cloud
func getBaseFqdn(fqdn string) string {
	slice := strings.Split(fqdn, ".")
	if len(slice) < 4 {
		return fqdn
	}

	return strings.Join(slice[len(slice)-4:], ".")
}

func generateToken(fqdn string) string {
	origin := getBaseFqdn(fqdn)
	hash, err := bcrypt.GenerateFromPassword([]byte(origin), bcrypt.MinCost)
	if err != nil {
		logrus.Errorf("Failed to generate token with %s, err: %v", fqdn, err)
		return defaultToken
	}
	return string(hash)
}

func compareToken(fqdn, token string) bool {
	origin := getBaseFqdn(fqdn)
	err := bcrypt.CompareHashAndPassword([]byte(token), []byte(origin))
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"token": token,
			"fqdn":  fqdn,
		}).Errorf("Failed to compare token, err: %v", err)
		return false
	}
	logrus.Debugf("Token %s matched with fqdn %s", token, fqdn)
	return true
}

func tokenMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// createDomain and getDomain have no need to check token
		if r.Method != http.MethodGet && r.Method != http.MethodPost {
			authorization := r.Header.Get("Authorization")
			token := strings.TrimLeft(authorization, "Bearer ")
			fqdn, ok := mux.Vars(r)["fqdn"]
			if ok {
				if !compareToken(fqdn, token) {
					returnHTTPError(w, http.StatusForbidden, errors.New("Forbidden to use"))
					return
				}
			} else {
				returnHTTPError(w, http.StatusForbidden, errors.New("Must specific the fqdn"))
				return
			}
		}

		next.ServeHTTP(w, r)
	})
}
